封装 继承 多态

面向对象追求 高内聚 低耦合

面向接口编程
优先使用组合而不是继承

将抽象和实现分离

factory（有共同基类）
封装了对象的创建
延迟了子类具体化

主要好处只记着基类就行，子类靠factory的成员列表查

abstractfactory（基类不同）
创建一组相关或者相互依赖的对象。
基本就是同一工厂用多个接口构造不同基类的示例

singlton

builder
把复杂对象的构建过程分离

prototype
其实就是通过拷贝构造函数，对已存在对象的复制clone()

以上几个模式都是负责类的创建工作


bridge
用来应对用户需求的不断变化，实现松耦合
主要是将抽象和实现彻底解耦，通过组合委托的方式实现
而且这种方式和继承的区别就是这是通过组合的方式实现分离
对抽象的实现部分修改，可以不必重新编译客户代码。
对用户隐藏实现。
它的最大价值在于实现和接口的独立。

adapter
主要是解决引用第三方库的问题
分类模式（继承方式实现）
对象模式（组合方式）
只是用来匹配接口，并不是用来大规模改变功能的。当然，细小的功能调整在实现适配器类的时候是可能的，但这不是适配器模式的目的。

decorator
通过组合给类添加新职责
利用OO中多态的思想来实现只要是Component型别的对象都可以提供修饰操作的类
可以不用再到父类添加接口进而影响别的子类

composite
终点在于生成批量管理类，叶子可以独立存在，也可以在集合里，集合和叶子有共同的基类，可生成递归树关系
leaf为什么要继承component？

flyweight
比如字体内容由不同实例共享是内部对象，字体大小和颜色给外部对象每个实例不同
里面包含一个类似工厂的东西,
比较像贴图管理器，给地址，然后生成贴图对象，已经生成过的贴图对象就直接返回

facade
用来整合不同类的接口组合执行后得到结果，不过是调用关系
其实就相当于一个wrapper

proxy
比如智能指针，proxy有在构造函数给proxy传指针的过程

--行为模式
template
一般的多态，实现算法的细节不同
反向控制结构效果，但是问题是有别的类想复用它的子类的问题

strategy
和template类似,都是为了把具体实现和抽象借口之间解耦
区别是strategy用组合实现，不同的算法是一个个类
template易于修改和扩展被复用的实现
缺点 破坏了封装性，继承中父类的实现细节暴露给了子类
父类实现更改时，所有子类都不得不改变
继承来的实现在运行期不能改变

组合，封装性好，实现和抽象依赖性小
可以运行期修改
缺点：系统中对象过多


state
1、去除switch case用
2、状态逻辑和动作实现分离，系统更易于扩展和维护
state的问题时：逻辑分散化，状态逻辑分散到了很多state的子类中，很难看到整个状态逻辑图，带来了代码维护问题

observer
比如mvc，struts
主要用途比如我更新了数据，多个模块都要监听到

memento
保存类的状态，做回退用

memento的关键时friend class originator
memento的接口都声明为private，以达到封装效果

mediator
专门处理对象间交互和通信的类，实现了系统对象间的松耦合，
了解一个对象总比深入熟悉n个对象好

command
实现调用操作的对象和操作的具体实现者的解耦


visitor
在不破坏类的前提下，为类增加新操作
关键是双分派技术，就是执行的操作取决于请求的种类和接收者的类型

chain of responsibility
vc是基于消息
最大优先是系统降低了耦合性，
请求发送者完全不必知道请求会被哪个应答对象处理

iterator
解决对一个聚合对象的遍历问题，把对聚合的遍历封装到了一个类中

interpreter
比如xml解析一类的